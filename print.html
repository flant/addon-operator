<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Addon-operator</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="OVERVIEW.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="RUNNING.html"><strong aria-hidden="true">2.</strong> Running Addon-operator</a></li><li class="chapter-item expanded "><a href="LIFECYCLE.html"><strong aria-hidden="true">3.</strong> Lifecycle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="LIFECYCLE-STEPS.html"><strong aria-hidden="true">3.1.</strong> Steps</a></li></ol></li><li class="chapter-item expanded "><a href="MODULES.html"><strong aria-hidden="true">4.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="HOOKS.html"><strong aria-hidden="true">4.1.</strong> Hooks</a></li><li class="chapter-item expanded "><a href="VALUES.html"><strong aria-hidden="true">4.2.</strong> Values</a></li></ol></li><li class="chapter-item expanded "><a href="metrics/ROOT.html"><strong aria-hidden="true">5.</strong> Metrics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metrics/SELF_METRICS.html"><strong aria-hidden="true">5.1.</strong> Self metrics</a></li><li class="chapter-item expanded "><a href="metrics/METRICS_FROM_HOOKS.html"><strong aria-hidden="true">5.2.</strong> Return metrics from hooks</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Addon-operator</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/flant/addon-operator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
<img src="image/logo-addon-operator-small.png" alt="addon-operator logo" />
</p>
<p align="center">
<a href="https://hub.docker.com/r/flant/addon-operator"><img src="https://img.shields.io/badge/docker-latest-2496ed.svg?logo=docker" alt="docker pull flant/addon-operator"/></a>
<a href="https://github.com/flant/addon-operator/discussions"><img src="https://img.shields.io/badge/GitHub-discussions-brightgreen" alt="GH Discussions"/></a>
<a href="https://t.me/kubeoperator"><img src="https://img.shields.io/badge/telegram-RU%20chat-179cde.svg?logo=telegram" alt="Telegram chat RU"/></a>
</p>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>You may use a prepared image <a href="https://hub.docker.com/r/flant/addon-operator">flant/addon-operator</a> to install addon-operator in a cluster. The image comprises a binary <code>addon-operator</code> file as well as several required tools: <code>helm</code>, <code>kubectl</code>, <code>jq</code>, <code>bash</code>.</p>
<p>The installation incorporates the image building process with <em>files of modules and hooks</em>, applying the necessary RBAC rights and deploying the image in the cluster.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>To experiment with modules, hooks, and values we’ve prepared some <a href="https://github.com/flant/addon-operator/tree/main/examples">examples</a>.</p>
<p><a href="https://deckhouse.io/">Deckhouse Kubernetes Platform</a> was an initial reason to create addon-operator, thus <a href="https://github.com/deckhouse/deckhouse/tree/main/modules">its modules</a> might become a vital source of inspiration for implementing your own modules.</p>
<p>Sharing your examples of using addon-operator is much appreciated. Please, use the <a href="https://github.com/flant/addon-operator/discussions/categories/show-and-tell">relevant Discussions section</a> for that.</p>
<h1 id="community"><a class="header" href="#community">Community</a></h1>
<p>Please feel free to reach developers/maintainers and users via <a href="https://github.com/flant/addon-operator/discussions">GitHub Discussions</a> for any questions regarding addon-operator.</p>
<p>You’re also welcome to follow <a href="https://twitter.com/flant_com">@flant_com</a> to stay informed about all our Open Source initiatives.</p>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Apache License 2.0, see <a href="https://github.com/flant/addon-operator/blob/main/LICENSE">LICENSE</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><strong>Addon-operator</strong> combines Helm charts with hooks and values storage to transform charts into smart modules that configure themselves and respond to changes in the cluster. It is a sister project for <a href="https://github.com/flant/shell-operator">shell-operator</a> and is actively used in <a href="https://github.com/deckhouse/deckhouse">Deckhouse Kubernetes Platform</a> to implement its modules.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>Discovery of values</strong> for Helm charts — parameters can be generated, calculated or retrieved from the cluster;</li>
<li><strong>Continuous discovery</strong> — parameters can be changed in response to cluster events;</li>
<li><strong>Controlled Helm execution</strong> — addon-operator monitors the Helm operation to ensure the Helm chart’s successful installation. Coming soon: use kubedog to track deploy status and more;</li>
<li><strong>Custom extra actions before and after running Helm</strong> as well as any other events via the hooks paradigm. See related <a href="https://flant.github.io/shell-operator/HOOKS.html">shell-operator capabilities</a>.</li>
</ul>
<p>Additionally, addon-operator provides:</p>
<ul>
<li>ease of maintenance of Kubernetes clusters: use the tools that Ops are familiar with to build your modules and hooks such as Bash, kubectl, Python, etc;</li>
<li>the execution queue of modules and hooks that ensures the launch sequence and repeated execution in case of an error, which <em>simplifies programming of modules</em> and ensures <em>predictable outcome</em> of their operation;</li>
<li>the possibility of <em>dynamic enabling/disabling</em> of a module (depending on detected parameters);</li>
<li>the ability to tie <em>conditions of module activation</em> to the activation of other modules;</li>
<li><em>the unified ConfigMap</em> for the configuration of all settings;</li>
<li>the ability to run Helm only if parameters have changed. In this case, <code>helm history</code> would output only releases with changes;</li>
<li><em>global hooks</em> for figuring out parameters and performing actions that affect several dependent modules;</li>
<li>off-the-shelf <em>metrics</em> for monitoring via Prometheus.</li>
</ul>
<h2 id="hooks-and-helm-values"><a class="header" href="#hooks-and-helm-values">Hooks and Helm values</a></h2>
<p>Hooks are triggered by Kubernetes events and in response to other stimuli.</p>
<p><img src="image/readme-1.gif" alt="Hooks are triggered by Kubernetes events" /></p>
<p>A hook is an executable file that can make changes to Kubernetes and set values of Helm (they are stored in the memory of addon-operator) during execution.</p>
<p><img src="image/readme-2.gif" alt="A hook is an executable file" /></p>
<p>Hooks are a part of the module. Also, there is a Helm chart in the module. If the hook makes changes to values, then addon-operator would upgrade the release of the Helm chart.</p>
<p><img src="image/readme-3.gif" alt="Hook is a part of the module" /></p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>There can be many modules.</p>
<p><img src="image/readme-4.gif" alt="Many modules" /></p>
<p>In addition to modules, addon-operator supports <strong>global hooks</strong> and <strong>global values</strong>. They have a <strong>storage of values</strong>. Global hooks are triggered by events and when active they can:</p>
<ul>
<li>Make changes to Kubernetes cluster;</li>
<li>Make changes to global values storage.</li>
</ul>
<p><img src="image/readme-5.gif" alt="Global hooks and global values" /></p>
<p>If the global hook changes values in the global storage, then addon-operator triggers an upgrade of releases of all Helm charts.</p>
<p><img src="image/readme-6.gif" alt="Changes in global values cause reinstallation" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-addon-operator"><a class="header" href="#running-addon-operator">Running Addon-operator</a></h1>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p><strong>GLOBAL_HOOKS_DIR</strong> — a directory with global hook files.</p>
<p><strong>MODULES_DIR</strong> — paths separated by colon where modules are located.</p>
<p><strong>UNNUMBERED_MODULE_ORDER</strong> — an integer number to use as the default order for modules without numbered prefix.</p>
<p><strong>ADDON_OPERATOR_NAMESPACE</strong> — a required parameter with namespace where Addon-operator is deployed.</p>
<p><strong>ADDON_OPERATOR_CONFIG_MAP</strong> — a name of ConfigMap to store values. Default is <code>addon-operator</code>.</p>
<p>Namespace and config map name are used to watch for ConfigMap changes. </p>
<p>Example of container:</p>
<pre><code>containers:
- image: addon-operator-image:latest
  env:
  - name: ADDON_OPERATOR_NAMESPACE
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace
  - name: ADDON_OPERATOR_CONFIG_MAP
    value: my-values   
</code></pre>
<p>With this variables Addon-operator would monitor ConfigMap/my-values object. </p>
<p><strong>ADDON_OPERATOR_LISTEN_ADDRESS</strong> — address for http server. Default is <code>0.0.0.0</code></p>
<p><strong>ADDON_OPERATOR_LISTEN_PORT</strong> — port for http server. Default is <code>9650</code>.</p>
<p>Addon-operator starts http server and listens on <code>ADDRESS:PORT</code>. There is a liveness probe and <code>/metrics</code> endpoint.</p>
<pre><code>  env:
  ...
  - name: ADDON_OPERATOR_LISTEN_ADDRESS
    valueFrom:
      fieldRef:
        fieldPath: status.podIP
  - name: ADDON_OPERATOR_LISTEN_PORT
    value: 9090
  livenessProbe:
    httpGet:
      path: /healthz
      port: 9090      
</code></pre>
<p><strong>ADDON_OPERATOR_PROMETHEUS_METRICS_PREFIX</strong> — a prefix for Prometheus metrics. Default is <code>addon_operator_</code>.</p>
<pre><code>  env
  - name: ADDON_OPERATOR_PROMETHEUS_METRICS_PREFIX
    value: dev_cluster_  
</code></pre>
<pre><code>curl localhost:9650/metrics

...
dev_cluster_live_ticks 32
...
</code></pre>
<p><strong>ADDON_OPERATOR_CRD_EXTRA_LABELS</strong> – string with CRDs label pairs.<br />
For example: <code>heritage=my-app,scope=extra</code><br />
Default is <code>heritage=addon-operator</code>.</p>
<p><strong>ADDON_OPERATOR_CRD_FILTER_PREFIXES</strong> – String of filters for the CRD, separated by commas. Default is <code>doc-,_</code>.</p>
<h3 id="kubernetes-client-settings"><a class="header" href="#kubernetes-client-settings">Kubernetes client settings</a></h3>
<p><strong>KUBE_CONFIG</strong> — a path to a kubernetes client config (~/.kube/config)</p>
<p><strong>KUBE_CONTEXT</strong> — a context name in a kubernetes client config (similar to a <code>--context</code> flag of a kubectl)</p>
<p><strong>KUBE_CLIENT_QPS</strong> and <strong>KUBE_CLIENT_BURST</strong> — qps and burst parameters to rate-limit requests to Kubernetes API server. Default qps is 5 and burst is 10 as in a <a href="https://github.com/kubernetes/client-go/blob/v0.17.0/rest/config.go#L44">rest/config.go</a> file.</p>
<h3 id="helm-settings"><a class="header" href="#helm-settings">Helm settings</a></h3>
<p>Addon-operator expects that “helm” binary is available in $PATH. It detects Helm version at start by executing “helm --help” command. If this is not appropriate by some reasons, you can use these settings:</p>
<p><strong>HELM_BIN_PATH</strong> — a path to a Helm binary.</p>
<p><strong>HELM_POST_RENDERER_PATH</strong> — a path to a Helm post-renderer binary.</p>
<p><strong>HELM3</strong> — set to “yes” to disable auto-detection and explicitly enable compatibility with helm3.</p>
<p><strong>HELM_IGNORE_RELEASE</strong> — a name of the release that should not be treated as the module’s release. Prevent self-destruction when addon-operator release is stored in the same namespace as releases for modules.</p>
<pre><code>env:
- name: HELM_IGNORE_RELEASE
  value: {{ .Release.Name }}
</code></pre>
<p><strong>HELM_MONITOR_KUBE_CLIENT_QPS</strong> — QPS for a rate limiter of a kubernetes client for Helm resources monitor.</p>
<p><strong>HELM_MONITOR_KUBE_CLIENT_BURST</strong> — Burst for a rate limiter of a kubernetes client for Helm resources monitor.</p>
<h3 id="logging-settings"><a class="header" href="#logging-settings">Logging settings</a></h3>
<p><strong>LOG_TYPE</strong> — Logging formatter type: <code>json</code>, <code>text</code> or <code>color</code>.</p>
<p><strong>LOG_LEVEL</strong> — Logging level: <code>debug</code>, <code>info</code>, <code>error</code>.</p>
<p><strong>LOG_NO_TIME</strong> — ‘true’ value will disable timestamp logging. Useful when output is redirected to logging system that already adds timestamps. Default is ‘false’.</p>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>Several tools are available for the debugging of addon-operator and hooks:</p>
<ul>
<li>You can get logs of an Addon-operator’s pod for analysis (by executing <code>kubectl logs -f po/POD_NAME</code>)</li>
<li>You can set the environment variable <code>LOG_LEVEL=debug</code> to include detailed debugging data into logs</li>
<li>Addon-operator inherits shell-operator’s debug CLI interface and a UNIX socket HTTP endpoint. A path to the endpoint can be configured with <code>DEBUG_UNIX_SOCKET</code> environment variable, the default path is 	“/var/run/addon-operator/debug.socket”.</li>
</ul>
<p>Available debug commands:</p>
<pre><code>addon-operator queue list [-o text|yaml|json]
    Dump tasks in all queues.

addon-operator global values [-o yaml|json]
    Dump current global values.

addon-operator global patches
    Dump current JSON patches for global values.

addon-operator global config [-o yaml|json]
    Dump global config values.

addon-operator module list [-o text|yaml|json]
    List available modules and their enabled status.

addon-operator module values [-o yaml|json] &lt;module_name&gt;
    Dump module values by name.

addon-operator module patches &lt;module_name&gt;
    Dump JSON patches for module values by name.

addon-operator module config [-o yaml|json] &lt;module_name&gt;
    Dump module config values by name.

addon-operator module resource-monitor [-o text|yaml|json]
    Dump resource monitors.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h1>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Module files are located in the <code>/modules</code> directory. The directory can be set via <code>$MODULES_DIR</code> variable. Global hook files are located in the <code>/global-hooks</code> directory (you can set your own directory with the <code>$GLOBAL_HOOKS_DIR</code> variable).</p>
<h2 id="startup-sequence"><a class="header" href="#startup-sequence">Startup sequence</a></h2>
<p>During startup, Addon-operator finds and initializes all global hooks. For more info, see <a href="HOOKS.html#initialization-of-global-hooks">HOOKS</a>.</p>
<p>After the global hooks initialization, Addon-operator executes all global <code>onStartup</code> hooks.</p>
<p>Then, the <em>global</em> hooks with <code>kubernetes</code> binding are executed with a binding context of type <code>Synchronization</code> and Kubernetes monitors for global hooks are started.</p>
<h2 id="reload-all-modules"><a class="header" href="#reload-all-modules">Reload all modules</a></h2>
<p>Next, the ‘reload all modules’ process is started. First, it finds all modules and their hooks.</p>
<p>Then, all global hooks with <code>beforeAll</code> binding are executed.</p>
<p>Next, the ‘module discovery’ process is started, it finds which modules are enabled by executing ‘enabled’ script for modules enabled in values.yaml and in ConfigMap/addon-operator.</p>
<p>Enabled modules are started.</p>
<p>During each module start-up, it executes all <code>onStartup</code> hooks and initializes the installation of a Helm chart. Prior to the installation of a Helm chart, the <code>beforeHelm</code> hook is executed. The <code>afterHelm</code> hook is executed after the installation.</p>
<p>When all modules are started, all global hooks with <code>afterAll</code> binding are executed.</p>
<h2 id="main-loop"><a class="header" href="#main-loop">Main loop</a></h2>
<p>After the first run of ‘reload all modules’, the main loop starts. It reacts to schedule and Kubernetes events, and to a values changes: it restarts a particular module if its values are changed and runs ‘reload all modules’ process again if global values are changed.</p>
<h2 id="named-queues"><a class="header" href="#named-queues">Named queues</a></h2>
<p>The Addon-operator supports named queues to execute hooks in parallel for <code>schedule</code> and <code>kubernetes/Event</code> bindings.</p>
<p>All other actions are handled in a single “main” queue:</p>
<ul>
<li>global hooks:
<ul>
<li><code>onStartup</code></li>
<li><code>kubernetes/Synchronization</code></li>
<li><code>beforeAll</code></li>
<li><code>afterAll</code></li>
</ul>
</li>
<li>module hooks:
<ul>
<li><code>onStartup</code></li>
<li><code>kubernetes/Synchronization</code></li>
<li><code>beforeHelm</code></li>
<li>execution of <code>helm</code> commands</li>
<li><code>afterHelm</code></li>
</ul>
</li>
</ul>
<p>This document mainly describes modules. To get more information on hooks, see <a href="HOOKS.html">HOOKS</a> document. To get a full view of how hooks, modules, <a href="VALUES.html">values</a>, binding contexts, and queues are interlinked, see <a href="LIFECYCLE-STEPS.html">LIFECYCLE-STEPS</a> document.</p>
<h2 id="module-lifecycle"><a class="header" href="#module-lifecycle">Module lifecycle</a></h2>
<p>The <code>onStartup</code> hooks of enabled module is executed at the startup of the Addon-operator or later on module enablement.</p>
<p>Next, the module’s chart is installed with <code>helm upgrade --install</code>. Before launching Helm, <code>beforeHelm</code> hooks are executed, after the launch, <code>afterHelm</code> hooks are executed.</p>
<p>After the launch the module would start responding to two types of events:</p>
<ul>
<li><code>schedule</code> — events that are generated by the crontab scheduler built in the addon-operator;</li>
<li><code>kubernetes</code> — events within the cluster that API server announces to the Addon-operator.</li>
</ul>
<p>When the module is deactivated, the Addon-operator launches command <code>helm delete --purge</code> and after the release deletion, the <code>afterDeleteHelm</code> hooks are executed.</p>
<p>All necessary hooks will be restarted if there are errors during the module activation or deactivation. For example, if an error occurred in the hook with <code>afterHelm</code> binding during the first module execution, then after a 5 seconds delay the <code>onStartup</code> and <code>beforeHelm</code> hooks are executed, the Helm chart is installed and then <code>afterHelm</code> hooks are executed.</p>
<h2 id="modules-discovery"><a class="header" href="#modules-discovery">Modules discovery</a></h2>
<p>The Addon-operator makes a list of all enabled modules for their execution and a list of disabled modules for the deletion of their Helm releases. This process is called ‘modules discovery’ and is started in the following cases:</p>
<ul>
<li>during the start of addon-operator</li>
<li>when an event to restart all modules occurs (see <a href="VALUES.html">VALUES</a>).</li>
</ul>
<p>Modules are disabled by default. The module can be enabled by a key with the module name suffixed by <code>Enabled</code>. This key should contain a boolean value and can be specified in these sources:</p>
<ul>
<li>$MODULES_DIR/values.yaml</li>
<li><code>values.yaml</code> files in modules directories</li>
<li>ConfigMap/addon-operator</li>
</ul>
<p>Boolean values from values.yaml files and ConfigMap/addon-operator are combined and if the result is equal to <code>false</code> or is empty, then the module is disabled.</p>
<p>If the value is <code>true</code>, an additional check is performed – the <code>enabled</code> script is executed (see below). If the script is present in the module and it returns <code>false</code>, then the module is considered disabled. If the script is not present or returns <code>true</code>, then the module is enabled.</p>
<p>If an error occurs during the ‘modules discovery’ process, then the module discovery is restarted every 5 seconds until successful execution. In this case, the execution of hooks with <code>schedule</code> and <code>kubernetes</code> bindings will be blocked in the “main” queue.</p>
<p>As a result of a ‘module discovery’ process, the tasks for the execution of all <em>enabled</em> modules, deletion of all <em>disabled</em> modules, and execution of all global hooks with the <code>afterAll</code> binding are added to the queue.</p>
<h3 id="enabled-script"><a class="header" href="#enabled-script">Enabled script</a></h3>
<p>A script or an executable file that returns the status of the module. The script has access to the module values in <code>$VALUES_PATH</code> and <code>$CONFIG_VALUES_PATH</code> files, more details about the values are available <a href="VALUES.html#using-the-values-in-enabled-scripts">here</a>. The variable <code>$MODULE_ENABLED_RESULT</code> passes the path to the file into which the script should write the module status: <code>true</code> or <code>false</code>.</p>
<p>Below is an example of the <code>enabled</code> script that disables the module when parameter <code>param2</code> is set to “stopMePlease”.</p>
<pre><code class="language-bash">#!/usr/bin/env bash

param2=$(jq -r '.simpleModule.param2' $VALUES_PATH)

if [[ $param2 == &quot;stopMePlease&quot; ]] ; then
  echo &quot;false&quot; &gt; $MODULE_ENABLED_RESULT
else
  echo &quot;true&quot; &gt; $MODULE_ENABLED_RESULT
fi

</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="keys-in-valuesyaml-files"><a class="header" href="#keys-in-valuesyaml-files">Keys in <code>values.yaml</code> files</a></h3>
<p>A module named <code>nginx-ingress</code> may have an <code>nginxIngressEnabled</code> flag in two files:</p>
<pre><code class="language-shell">$ cat modules/values.yaml

nginxIngressEnabled: true

$ cat modules/001-nginx-ingress/values.yaml

nginxIngressEnabled: false
</code></pre>
<p>Module <code>nginx-ingress</code> is enabled in <code>modules/values.yaml</code> but disabled in <code>modules/001-nginx-ingress/values.yaml</code>. The final result is that the module is disabled.</p>
<p>Also, note that the module’s directory name is kebab-cased but keys in values.yaml are camelCased (see <a href="VALUES.html#values-storage">VALUES</a>).</p>
<h3 id="valuesyaml-and-configmap"><a class="header" href="#valuesyaml-and-configmap"><code>values.yaml</code> and ConfigMap</a></h3>
<p>A module named ‘some-module’ has no <code>someModuleEnabled</code> flag in <code>modules/001-some-module/values.yaml</code> but this flag is defined in a ConfigMap and the module has <code>enabled</code> script:</p>
<pre><code class="language-shell">$ cat modules/values.yaml

global:
  param1: 100
someModuleEnabled: false

$ cat modules/001-some-module/values.yaml

someModule:
  param1: &quot;String&quot;


$ kubectl -n addon-operator get cm/addon-operator -o yaml

data:
  global: |
    param1: 200
  someModule: |
    param1: &quot;Long string&quot;
    param2: &quot;FOO&quot;
  someModuleEnabled: &quot;true&quot;

$ cat modules/01-some-module/enabled

#!/bin/bash

echo false &gt; $MODULE_ENABLED_RESULT
</code></pre>
<p>Module <code>some-module</code> is explicitly disabled in <code>modules/values.yaml</code> but enabled by <code>someModuleEnabled</code> key in ConfigMap/addon-operator. Thus enabled script is executed and returns <code>false</code>. So the final result is that the module is disabled.</p>
<h2 id="task-queues"><a class="header" href="#task-queues">Task queues</a></h2>
<p>Task queues are simple FIFO queues. The Addon-operator processes an event, creates a task and adds it to the particular named queue. Each named queue has a queue handler which runs the first task and proceeds to the next.</p>
<p>Each task is processed until successful completion. In case of an error, the task is returned to the start of the queue and executed with an exponentially growing delay (from 5s to 30s). When executing tasks for the <code>kubernetes</code> and <code>schedule</code> events, the queue handler ignores execution errors if the <code>allowFailure: true</code> flag is specified in the binding configuration.</p>
<h2 id="queue-monitoring"><a class="header" href="#queue-monitoring">Queue monitoring</a></h2>
<p>You can use Prometheus metrics to monitor the queue. For details, see <a href="metrics/ROOT.html">METRICS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="steps-of-addon-operator-lifecycle"><a class="header" href="#steps-of-addon-operator-lifecycle">Steps of addon-operator lifecycle</a></h1>
<p>This document is intended to give a full view of how <a href="HOOKS.html">hooks</a>, <a href="MODULES.html">modules</a>, <a href="VALUES.html">values</a>, binding contexts, and queues are interlinked within the Addon-operator’s <a href="LIFECYCLE.html">lifecycle</a>.</p>
<p>Startup steps:</p>
<p><a name="global-onstartup"></a>1. execute global hooks with ‘onStartup’ binding ordered by the ORDER value (see <a href="HOOKS.html#onstartup">onStartup</a>)</p>
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>[{&quot;binding&quot;:&quot;onStartup&quot;}]</code></li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger any event</li>
</ul>
</li>
</ul>
<p><a name="global-kubernetes-synchronization"></a>2. execute global hooks with ‘kubernets’ binding in alphabetic order (see <a href="HOOKS.html#kubernetes">kubernetes</a>)</p>
<ul>
<li>a hook executes several times for each defined ‘kubernetes’ binding</li>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>&quot;type&quot;: &quot;Synchronization&quot;</code>
<ul>
<li><code>&quot;objects&quot;</code> contains all existed objects</li>
<li><code>&quot;snapshots&quot;</code> contains existed objects from previous bindings</li>
</ul>
</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger an event</li>
</ul>
</li>
</ul>
<p><a name="reload-all-modules"></a>‘Reload all modules’ steps:</p>
<p><a name="global-beforeall"></a>3. execute global hooks with ‘beforeAll’ binding ordered by ORDER value (see <a href="HOOKS.html#beforeall">beforeAll</a>)</p>
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li>“snapshots” contains existed objects from all ‘kubernetes’ bindings of this hook</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger an event</li>
</ul>
</li>
</ul>
<p><a name="discover-modules"></a>4. discover modules</p>
<ul>
<li>get merged ‘enabled’ state from config for each module
<ul>
<li>false</li>
<li>‘{moduleName}Enabled’ value from modules/values.yaml</li>
<li>‘{moduleName}Enabled’ value from modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}Enabled’ value from ConfigMap</li>
</ul>
</li>
<li>run ‘enabled’ script if merged ‘enabled’ state is true
<ul>
<li>input
<ul>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of previously enabled modules</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>‘enabled’ state ($MODULE_ENABLED_RESULT temporary file)
<ul>
<li>if hook return “false”, hook state is disabled</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>no ‘enabled’ script
<ul>
<li>merged ‘enabled’ state is used</li>
</ul>
</li>
<li>create 3 lists
<ul>
<li>modules to enable</li>
<li>modules to delete (disabled)</li>
<li>modules to purge (there is helm release, but no module directory)</li>
</ul>
</li>
</ul>
<p><a name="module-run"></a>5. ‘module run’ for each enabled module</p>
<ul>
<li>if startup or if module just become enabled
<ul>
<li>execute module hooks with ‘onStartup’ binding ordered by the ORDER value (see <a href="HOOKS.html#onstartup">onStartup</a>)
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>{&quot;binding&quot;:&quot;onStartup&quot;}</code></li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks temporary file</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after hook run</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger an event</li>
</ul>
</li>
</ul>
</li>
<li>execute module hooks with ‘kubernetes’ bindings ordered in alphabetic order
<ul>
<li>a hook executes several times for each defined ‘kubernetes’ binding</li>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>&quot;type&quot;: &quot;Synchronization&quot;</code>
<ul>
<li><code>&quot;objects&quot;</code> contains all existed objects</li>
<li><code>&quot;snapshots&quot;</code> contains existed objects from previous bindings</li>
</ul>
</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger an event</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>execute module hooks with ‘beforeHelm’ binding ordered by the ORDER value (see <a href="HOOKS.html#beforehelm">beforeHelm</a>)
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>{&quot;binding&quot;:&quot;beforeHelm&quot;}</code></li>
<li>extra field <code>&quot;snaphots&quot;</code> contains existed objects from all ‘kubernetes’ bindings of this hook</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)</li>
<li>applied to ConfigMap just after the hook execution</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)</li>
<li>saved in memory</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger an event</li>
</ul>
</li>
</ul>
</li>
<li>check if <code>helm upgrade</code> should run
<ul>
<li>get saved checksum from last release values</li>
<li>render templates
<ul>
<li>if checksum is changed → helm release should be upgraded</li>
</ul>
</li>
<li>get helm resources defined in templates
<ul>
<li>if there are absent resources → helm release should be upgraded</li>
</ul>
</li>
</ul>
</li>
<li>run <code>helm upgrade --install</code>
<ul>
<li>values (unique file in a temporary directory)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in /modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
<li>release name
<ul>
<li>module name in kebab-case</li>
<li>name from Chart.yaml is ignored</li>
</ul>
</li>
<li>namespace
<ul>
<li>$ADDON_OPERATOR_NAMESPACE (see <a href="RUNNING.html">RUNNING</a>)</li>
</ul>
</li>
</ul>
</li>
<li>execute module hooks with ‘afterHelm’ binding ordered by the ORDER value (see <a href="HOOKS.html#afterhelm">afterHelm</a>)
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>{&quot;binding&quot;:&quot;afterHelm&quot;}</code></li>
<li>extra field <code>&quot;snaphots&quot;</code> contains existed objects from all ‘kubernetes’ bindings of this hook</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>if module values are changed, restart ‘module run’</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="module-delete"></a>6. ‘module delete’ for each disabled module</p>
<ul>
<li>run <code>helm delete --purge</code></li>
<li>execute module hooks with ‘afterDeleteHelm’ binding ordered by the ORDER value (see <a href="HOOKS.html#afterdeletehelm">afterDeleteHelm</a>)
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>{&quot;binding&quot;:&quot;afterDeleteHelm&quot;}</code></li>
<li>extra field <code>&quot;snaphots&quot;</code> contains existed objects from all ‘kubernetes’ bindings of this hook</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>values changes do not trigger an event</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="module-purge"></a>7. ‘module purge’ for each non-existent module</p>
<ul>
<li>run <code>helm delete --purge</code></li>
</ul>
<p><a name="global-afterall"></a>8. execute global hooks with ‘afterAll’ binding ordered by the ORDER value (see <a href="HOOKS.html#afterall">afterAll</a>)</p>
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>{&quot;binding&quot;:&quot;afterAll&quot;}</code></li>
<li>extra field “snapshots” contains existed objects from all ‘kubernetes’ bindings of this hook</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>if values are changed, re-run ‘Reload all modules’ steps 3 to 8.</li>
</ul>
</li>
</ul>
<p><strong>Reaction to events</strong></p>
<p><a name="global-kubernetes-event"></a>9. ‘kubernetes’ event for <em>global</em> hook (see <a href="HOOKS.html#kubernetes">kubernetes</a>)</p>
<ul>
<li>hook execution is queued in “main” or in a named queue according to the binding configuration</li>
<li>queue handler runs a hook:
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>&quot;type&quot;: &quot;Event&quot;</code>
<ul>
<li><code>&quot;object&quot;</code> contains a related object</li>
<li><code>&quot;filterResult&quot;</code> contains a result of jqFilter</li>
<li><code>&quot;snapshots&quot;</code> contains existed objects from other bindings</li>
</ul>
</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>‘global values changed’ if global section or *Enabled flags are changed</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="module-kubernetes-event"></a>10. ‘kubernetes’ event for <em>module</em> hook (see <a href="HOOKS.html#kubernetes">kubernetes</a>)</p>
<ul>
<li>hook execution is queued in “main” or in a named queue according to the binding configuration</li>
<li>queue handler runs a hook:
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>&quot;type&quot;: &quot;Event&quot;</code>
<ul>
<li><code>&quot;object&quot;</code> contains a related object</li>
<li><code>&quot;filterResult&quot;</code> contains a result of jqFilter</li>
<li><code>&quot;snapshots&quot;</code> contains existed objects from other bindings</li>
</ul>
</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>‘global values changed’ if global values are changed</li>
<li>‘modules values changed’ if module values are changed</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="global-schedule-event"></a>11. ‘schedule’ event for <em>global</em> hook (see <a href="HOOKS.html#schedule">schedule</a>)</p>
<ul>
<li>hook execution is queued in “main” or in a named queue according to the binding configuration</li>
<li>queue handler runs a hook:
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>&quot;snapshots&quot;</code> contains existed objects from other bindings</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>‘global values changed’ if global section or *Enabled flags are changed</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="module-schedule-event"></a>12. ‘schedule’ event for <em>module</em> hook (see <a href="HOOKS.html#schedule">schedule</a>)</p>
<ul>
<li>hook execution is queued in “main” or in a named queue according to the binding configuration</li>
<li>queue handler runs a hook:
<ul>
<li>input
<ul>
<li>binding context ($BINDING_CONTEXT_PATH temporary file)
<ul>
<li><code>&quot;snapshots&quot;</code> contains existed objects from other bindings</li>
</ul>
</li>
<li>config ($CONFIG_VALUES_PATH temporary file)
<ul>
<li>‘global’ section in ConfigMap</li>
<li>‘{moduleName}’ section in ConfigMap</li>
</ul>
</li>
<li>values ($VALUES_PATH temporary file)
<ul>
<li>‘global values’ merged from:
<ul>
<li>‘global’ section in modules/values.yaml</li>
<li>‘global’ section in ConfigMap</li>
<li>patched with patches saved from previous global hooks</li>
<li>extra field ‘global.enabledModules’ contains a list of <strong>all</strong> enabled modules created by ‘discover modules’ step (4)</li>
</ul>
</li>
<li>‘module values’ merged from:
<ul>
<li>‘{moduleName}’ section in modules/values.yaml</li>
<li>‘{moduleName}’ section in modules/{moduleName}/values.yaml</li>
<li>‘{moduleName}’ section in ConfigMap</li>
<li>patched with patches saved from previous module hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>output
<ul>
<li>config patches ($CONFIG_VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>applied to ConfigMap just after the hook execution</li>
</ul>
</li>
<li>values patches ($VALUES_JSON_PATCH_PATH temporary file)
<ul>
<li>saved in memory</li>
</ul>
</li>
</ul>
</li>
<li>events after execution
<ul>
<li>trigger ‘global values changed’ if global values are changed</li>
<li>trigger ‘modules values changed’ if module values are changed</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="global-values-changed"></a>13. ‘global values changed’ event (see <a href="HOOKS.html#global-hook">global hook</a>)</p>
<ul>
<li>create ‘Reload all modules’ task in the “main” queue (steps 3 to 8)</li>
</ul>
<p><a name="module-values-changed"></a>14. ‘module values changed’ event (see <a href="HOOKS.html#module-hook">module hook</a>)</p>
<ul>
<li>create ‘module run’ task in the “main” queue
<ul>
<li>step 5 without <code>onStartup</code> and <code>kubernetes@Synchronization</code> hooks</li>
</ul>
</li>
</ul>
<p><a name="helm-resources-absent"></a>15. ‘helm resources absent’ event (see <a href="MODULES.html#release-auto-healing">auto-healing</a>)</p>
<ul>
<li>create ‘module run’ task in the “main” queue
<ul>
<li>step 5 without <code>onStartup</code> and <code>kubernetes@Synchronization</code> hooks</li>
</ul>
</li>
</ul>
<p><a name="configmap-changed"></a>16. ConfigMap is changed (see <a href="VALUES.html#configmapaddon-operator">ConfigMap/addon-operator</a>)</p>
<ul>
<li>values in global section are changed
<ul>
<li>create ‘Reload all modules’ task in the “main” queue (steps 3 to 8)</li>
</ul>
</li>
<li>*Enabled flags are changed
<ul>
<li>create ‘Reload all modules’ task in the “main” queue (steps 3 to 8)</li>
</ul>
</li>
<li>values in modules sections are changed
<ul>
<li>create ‘module run’ task in the “main” queue
<ul>
<li>step 5 without <code>onStartup</code> and <code>kubernetes@Synchronization</code> hooks</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-structure"><a class="header" href="#module-structure">Module structure</a></h1>
<p>A module is a directory with files. Addon-operator searches for the modules directories in <code>/modules</code> or in the paths specified by the $MODULES_DIR variable. The module has the same name as the corresponding directory excluding the numeric prefix.</p>
<p>An example of the file structure of the module:</p>
<pre><code>/modules/001-simple-module
├── crds
│   ├── doc-ru-projects.yaml
│   ├── doc-ru-projecttemplate.yaml
│   ├── projects.yaml
│   ├── projecttemplate.yaml
├── hooks
│   ├── module-hook-1.sh
│   ├── ...
│   └── module-hook-N.sh
├── openapi
│   ├── config-values.yaml
│   └── values.yaml
├── templates
│   ├── config-maps.yaml
│   ├── ...
│   └── daemon-set.yaml
├── enabled
├── README.md
├── .helmignore
├── Chart.yaml
└── values.yaml
</code></pre>
<ul>
<li><code>crds</code> — a directory with crd files.</li>
<li><code>hooks</code> — a directory with hooks.</li>
<li><code>openapi</code> — <a href="VALUES.html">OpenAPI schemas</a> for config values and for helm values.</li>
<li><code>enabled</code> — a script that gets the status of module (is it enabled or not). See the <a href="LIFECYCLE.html#modules-discovery">modules discovery</a> process.</li>
<li><code>Chart.yaml</code>, <code>.helmignore</code>, <code>templates</code> — a Helm chart files.</li>
<li><code>README.md</code> — an optional file with the module description.</li>
<li><code>values.yaml</code> – default values for chart in a <a href="VALUES.html">YAML format</a>.</li>
</ul>
<p>The name of this module is <code>simple-module</code>. values.yaml should contain a section <code>simpleModule</code> and a <code>simpleModuleEnabled</code> flag (see <a href="VALUES.html#values-storage">VALUES</a>). </p>
<h1 id="notes-on-how-helm-is-used"><a class="header" href="#notes-on-how-helm-is-used">Notes on how Helm is used</a></h1>
<h2 id="valuesyaml"><a class="header" href="#valuesyaml">values.yaml</a></h2>
<p>Addon-operator does not use values.yaml as the only source of values for the chart. It generates a new file with a merged set of values (also mixing values from this file (see <a href="VALUES.html#merged-values">VALUES</a>).</p>
<h2 id="chartyaml"><a class="header" href="#chartyaml">Chart.yaml</a></h2>
<p>We recommend to define the “version” field in your Chart.yaml as “0.0.1” and use VCS to control versions. We also recommend to explicitly specify the “name” field even despite it is ignored: Addon-operator passes the module name to the Helm as a release name.</p>
<h2 id="releases-deduplication"><a class="header" href="#releases-deduplication">Releases deduplication</a></h2>
<p>A module’s execution might be triggered by an event that does not change the values used by Helm templates (see <a href="LIFECYCLE.html#modules-discovery">modules discovery</a>). Re-running Helm will lead to an “empty” release. To avoid this, Addon-operator runs a <code>helm template</code> command and compares a checksum of output with a saved checksum and starts the installation of a Helm chart only if there are changes.</p>
<h2 id="release-auto-healing"><a class="header" href="#release-auto-healing">Release auto-healing</a></h2>
<p>The Addon-operator monitors resources defined by a Helm chart and triggers an update if something is deleted. This is useful for resources that Helm can’t update without deletion. It is worth noting, that resource deletion by hooks is smartly ignored to prevent needless updates.</p>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<ul>
<li>The Addon-operator’s <a href="LIFECYCLE.html">lifecycle</a>
<ul>
<li>detailed picture of lifecycle <a href="LIFECYCLE-STEPS.html">steps</a></li>
</ul>
</li>
<li><a href="VALUES.html">Values</a></li>
<li><a href="HOOKS.html">Hooks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<p>A hook is an executable file that the Addon-operator executes when some event occurs. It can be a script or a compiled program written in any programming language.</p>
<p>The Addon-operator pursues an agreement stating that the information is transferred to hooks via files and results of hook’s execution are also stored in files. Paths to files are passed via environment variables. The output to stdout will be written to the log, except for the case with the configuration output (run with <code>--config</code> flag). Such an agreement simplifies the work with the input data and reporting the results of the hook execution.</p>
<h2 id="global-hooks"><a class="header" href="#global-hooks">Global hooks</a></h2>
<p>Global hooks are stored in the <code>$GLOBAL_HOOKS_DIR/hooks</code> directory. The Addon-operator recursively searches all executable files in it (<code>lib</code> subdirectory ignored) and runs them with the <code>--config</code> flag. Each hook prints its events binding configuration in JSON or YAML format to stdout. If the execution fails, the Addon-operator terminates with the code of 1.</p>
<p>Bindings from <a href="https://github.com/flant/shell-operator">shell-operator</a> are available for global hooks: <a href="HOOKS.html#onstartup">onStartup</a>, <a href="HOOKS.html#schedule">schedule</a> and <a href="HOOKS.html#kubernetes">kubernetes</a>. The bindings to the events of the modules discovery process are also available: <a href="HOOKS.html#beforeall">beforeAll</a> and <a href="HOOKS.html#afterall">afterAll</a> (see <a href="LIFECYCLE.html#modules-discovery">modules discovery</a>).</p>
<p>During execution, a global hook receives global values. These values can be modified by the hook to share data with global hooks, module hooks, and Helm templates. If the hook changes global values, the ‘global values changed’ event is generated and all modules are reloaded. For details on values storage, see <a href="VALUES.html">VALUES</a>. See also <a href="LIFECYCLE.html#reload-all-modules">an overview</a> and <a href="LIFECYCLE-STEPS.html#reload-all-modules">a detailed description</a> of ‘Reload all modules’ process.</p>
<h2 id="module-hook"><a class="header" href="#module-hook">Module hook</a></h2>
<p>Module hooks are executable files stored in the <code>hooks</code> subdirectory of the module. During the <a href="LIFECYCLE.html#modules-discovery">‘modules discovery’</a> process, if module appears to be enabled, the Addon-operator searches for executable files in <code>hooks</code> directory and executes them with <code>--config</code> flag. Each hook prints its event binding configuration in JSON or YAML format to stdout. The module discovery process restarts if an error occurs.</p>
<p>Bindings from <a href="https://github.com/flant/shell-operator">shell-operator</a> are available for module hooks: <a href="HOOKS.html#schedule">schedule</a> and <a href="HOOKS.html#kubernetes">kubernetes</a>. The bindings of the module lifecycle are also available: <code>onStartup</code>, <code>beforeHelm</code>, <code>afterHelm</code>, <code>afterDeleteHelm</code> — see <a href="LIFECYCLE.html#module-lifecycle">module lifecycle</a>.</p>
<p>During execution, a module hook receives global values and module values. Module values can be modified by the hook to share data with other hooks of the same module. If the hook changes module values, the ‘module values changed’ event is generated and then the module is reloaded. For details on values storage, see <a href="VALUES.html">VALUES</a>. See also a <a href="LIFECYCLE.html#module-lifecycle">module lifecycle</a> and a <a href="LIFECYCLE-STEPS.html#module-run">module run</a> detailed description.</p>
<h2 id="bindings"><a class="header" href="#bindings">Bindings</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<table><thead><tr><th>Binding</th><th>Global?</th><th>Module?</th><th>Info</th></tr></thead><tbody>
<tr><td><a href="HOOKS.html#onstartup">onStartup</a>↗</td><td>✓</td><td>–</td><td>On Addon-operator startup</td></tr>
<tr><td><a href="HOOKS.html#onstartup">onStartup</a>↗</td><td>–</td><td>✓</td><td>On Addon-operator startup or module enablement</td></tr>
<tr><td><a href="HOOKS.html#beforeall">beforeAll</a>↗</td><td>✓</td><td>–</td><td>Before any modules are executed</td></tr>
<tr><td><a href="HOOKS.html#afterall">afterAll</a>↗</td><td>✓</td><td>–</td><td>After all modules are executed</td></tr>
<tr><td><a href="HOOKS.html#beforehelm">beforeHelm</a>↗</td><td>–</td><td>✓</td><td>Before executing <code>helm install</code></td></tr>
<tr><td><a href="HOOKS.html#afterhelm">afterHelm</a>↗</td><td>–</td><td>✓</td><td>After executing <code>helm install</code></td></tr>
<tr><td><a href="HOOKS.html#afterdeletehelm">afterDeleteHelm</a>↗</td><td>–</td><td>✓</td><td>After executing <code>helm delete</code></td></tr>
<tr><td><a href="HOOKS.html#schedule">schedule</a>↗</td><td>✓</td><td>✓</td><td>Run on schedule</td></tr>
<tr><td><a href="HOOKS.html#kubernetes">kubernetes</a>↗</td><td>✓</td><td>✓</td><td>Run on event from Kubernetes</td></tr>
</tbody></table>
<h3 id="onstartup"><a class="header" href="#onstartup">onStartup</a></h3>
<p>Example:</p>
<pre><code class="language-yaml">configVersion: v1
onStartup: ORDER
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ORDER</code> — an integer value that specifies an execution order. When added to the “main” queue, the hooks will be sorted by this value and then alphabetically by file name.</li>
</ul>
<h3 id="beforeall"><a class="header" href="#beforeall">beforeAll</a></h3>
<p>Example:</p>
<pre><code class="language-yaml">configVersion: v1
beforeAll: ORDER
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ORDER</code> — an integer value that specifies an execution order. When added to the “main” queue, the hooks will be sorted by this value and then alphabetically by file name.</li>
</ul>
<h3 id="afterall"><a class="header" href="#afterall">afterAll</a></h3>
<p>Example:</p>
<pre><code class="language-yaml">configVersion: v1
afterAll: ORDER
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ORDER</code> — an integer value that specifies an execution order. When added to the “main” queue, the hooks will be sorted by this value and then alphabetically by file name.</li>
</ul>
<h3 id="beforehelm"><a class="header" href="#beforehelm">beforeHelm</a></h3>
<p>Example:</p>
<pre><code class="language-yaml">configVersion: v1
beforeHelm: ORDER
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ORDER</code> — an integer value that specifies an execution order. When added to the “main” queue, the hooks will be sorted by this value and then alphabetically by file name.</li>
</ul>
<h3 id="afterhelm"><a class="header" href="#afterhelm">afterHelm</a></h3>
<p>Example:</p>
<pre><code class="language-yaml">configVersion: v1
afterHelm: ORDER
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ORDER</code> — an integer value that specifies an execution order. When added to the “main” queue, the hooks will be sorted by this value and then alphabetically by file name.</li>
</ul>
<h3 id="afterdeletehelm"><a class="header" href="#afterdeletehelm">afterDeleteHelm</a></h3>
<p>Example:</p>
<pre><code class="language-yaml">configVersion: v1
afterDeleteHelm: ORDER
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ORDER</code> — an integer value that specifies an execution order. When added to the “main” queue, the hooks will be sorted by this value and then alphabetically by file name.</li>
</ul>
<h3 id="schedule"><a class="header" href="#schedule">schedule</a></h3>
<p>See the <a href="https://flant.github.io/shell-operator/HOOKS.html#schedule">schedule binding</a> from the Shell-operator.</p>
<h3 id="kubernetes"><a class="header" href="#kubernetes">kubernetes</a></h3>
<p>See the <a href="https://flant.github.io/shell-operator/HOOKS.html#kubernetes">kubernetes binding</a> from the Shell-operator.</p>
<blockquote>
<p>Note: Addon-operator requires a ServiceAccount with the appropriate <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a> permissions. See <code>addon-operator-rbac.yaml</code> files in <a href="https://github.com/flant/addon-operator/tree/main/examples">examples</a>.</p>
</blockquote>
<h2 id="execution-on-event"><a class="header" href="#execution-on-event">Execution on event</a></h2>
<p>When an event associated with a hook is triggered, Addon-operator executes the hook without arguments and passes the global or module values from the storage of the values via temporary files. In response, a hook could return JSON patches to modify values. The detailed description of the storage of the values is available in <a href="VALUES.html">VALUES</a> document.</p>
<h3 id="binding-context"><a class="header" href="#binding-context">Binding context</a></h3>
<p>The binding context is a piece of information about the event which caused the hook execution.</p>
<p>The <code>$BINDING_CONTEXT_PATH</code> environment variable contains the path to a file with a JSON array of structures with the following fields:</p>
<ul>
<li><code>binding</code> is a string from the <code>name</code> parameter for <code>schedule</code> or <code>kubernetes</code> bindings. Its value is a <em>binding type</em> if the parameter is not set and for other hooks. For example, the binding context for <code>beforeAll</code> binding type:</li>
</ul>
<pre><code class="language-json">[{&quot;binding&quot;:&quot;beforeAll&quot;}]
</code></pre>
<p>The binding context for <code>schedule</code> and <code>kubernetes</code> hooks contains additional fields, described in Shell-operator <a href="https://flant.github.io/shell-operator/HOOKS.html#binding-context">documentation</a>.</p>
<p><code>beforeAll</code> and <code>afterAll</code> global hooks and <code>beforeHelm</code>, <code>afterHelm</code>, and <code>afterDeleteHelm</code> module hooks are executed with the binding context that includes a <code>snapshots</code> field, which contains all Kubernetes objects that match hook’s <code>kubernetes</code> bindings configurations.</p>
<p>For example, a global hook with <code>kubernetes</code> and <code>beforeAll</code> bindings may have this configuration:</p>
<pre><code class="language-yaml">configVersion: v1
beforeAll: 10
kubernetes:
- name: monitor-pods
  apiVersion: v1
  kind: Pod
  jqFilter: &quot;.metadata.labels&quot;
</code></pre>
<p>This hook will be executed <em>before</em> updating the Helm release with this binding context:</p>
<pre><code class="language-yaml">[{&quot;binding&quot;: &quot;beforeAll&quot;,
&quot;snapshots&quot;: {
  &quot;monitor-pods&quot;: [
    {
      &quot;object&quot;: {
        &quot;kind&quot;: &quot;Pod&quot;,
        &quot;apiVersion&quot;: &quot;v1&quot;,
        &quot;metadata&quot;: {
          &quot;name&quot;:&quot;pod-1r62e3&quot;,
          &quot;namespace&quot;:&quot;default&quot;, ...},
        ...
      },
      &quot;filterResult&quot;: {
        &quot;label1&quot;: &quot;label value&quot;,
        ...
      },
    },
    ...
    more pods
    ...
  ]
}
}]
</code></pre>
<h3 id="synchronization-for-global-hooks"><a class="header" href="#synchronization-for-global-hooks">Synchronization for global hooks</a></h3>
<p><a href="https://flant.github.io/shell-operator/HOOKS.html#synchronization-binding-context">Synchronization</a> is the first run of global hooks with “kubernetes” bindings. As with the Shell-operator, it executes right after the successful completion of global “onStartup” hooks, but the following behavior is slightly different. By default, the Addon-operator executes “beforeAll” hooks after the completion of hooks with <code>executeHookOnSynchronization: true</code>. Set <code>waitForSynchronization: false</code> to execute these hooks in parallel with “beforeAll” hooks.</p>
<p>For example, a global hook with <code>kubernetes</code> and <code>beforeAll</code> bindings may have this configuration:</p>
<pre><code class="language-yaml">configVersion: v1
beforeAll: 10
kubernetes:
- name: monitor-pods
  apiVersion: v1
  kind: Pod
  jqFilter: &quot;.metadata.labels&quot;
- name: monitor-nodes
  apiVersion: v1
  kind: Node
  jqFilter: &quot;.metadata.labels&quot;
  queue: nodes-handling
  executeHookOnSynchronization: false
- name: monitor-cms
  apiVersion: v1
  kind: ConfigMap
  jqFilter: &quot;.metadata.labels&quot;
  queue: config-map-handling
  waitForSynchronization: false
- name: monitor-secrets
  apiVersion: v1
  kind: Secret
  jqFilter: &quot;.metadata.labels&quot;
  queue: secrets-handling
  executeHookOnSynchronization: false
  waitForSynchronization: false
</code></pre>
<p>This hook will be executed after “onStartup” as follows:</p>
<ul>
<li>Run hook with binding context for the “monitor-pods” binding in the “main” queue.</li>
<li>Fill snapshot for the “monitor-nodes” binding, do not execute hook.</li>
<li>Run in parallel:
<ul>
<li>hook with the “beforeAll” binding context in the “main” queue</li>
<li>hook with the “monitor-cms” binding context in the “config-map-handling” queue</li>
<li>fill snapshot for the “monitor-secrets” binding.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: there is no guarantee that the “beforeAll” binding context contains snapshots with ConfigMaps and Secrets.</p>
</blockquote>
<h3 id="synchronization-for-module-hooks"><a class="header" href="#synchronization-for-module-hooks">Synchronization for module hooks</a></h3>
<p><a href="https://flant.github.io/shell-operator/HOOKS.html#synchronization-binding-context">Synchronization</a> is the first run of module hooks with “kubernetes” bindings after module enablement. It executes right after the successful completion of the module’s “onStartup” hooks. By default, the Addon-operator executes “beforeHelm” hooks after the completion of hooks with <code>executeHookOnSynchronization: true</code>. Set <code>waitForSynchronization: false</code> to execute these hooks in parallel with “beforeHelm” hooks.</p>
<p>For example, a module hook with <code>kubernetes</code> and <code>beforeHelm</code> bindings may have this configuration:</p>
<pre><code class="language-yaml">configVersion: v1
beforeHelm: 10
kubernetes:
- name: monitor-pods
  apiVersion: v1
  kind: Pod
  jqFilter: &quot;.metadata.labels&quot;
- name: monitor-nodes
  apiVersion: v1
  kind: Node
  jqFilter: &quot;.metadata.labels&quot;
  queue: nodes-handling
  executeHookOnSynchronization: false
- name: monitor-cms
  apiVersion: v1
  kind: ConfigMap
  jqFilter: &quot;.metadata.labels&quot;
  queue: config-map-handling
  waitForSynchronization: false
- name: monitor-secrets
  apiVersion: v1
  kind: Secret
  jqFilter: &quot;.metadata.labels&quot;
  queue: secrets-handling
  executeHookOnSynchronization: false
  waitForSynchronization: false
</code></pre>
<p>This hook will be executed after “onStartup” as follows:</p>
<ul>
<li>Run hook with binding context for the “monitor-pods” binding in the “main” queue.</li>
<li>Fill snapshot for the “monitor-nodes” binding, do not execute hook.</li>
<li>Run in parallel: 
<ul>
<li>hook with the “beforeHelm” binding context in the “main” queue</li>
<li>hook with the “monitor-cms” binding context in the “config-map-handling” queue</li>
<li>fill snapshot for the “monitor-secrets” binding</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: there is no guarantee that the “beforeHelm” binding context contains snapshots with ConfigMaps and Secrets.</p>
</blockquote>
<h3 id="execution-rate"><a class="header" href="#execution-rate">Execution rate</a></h3>
<p>Hook configuration has a <code>settings</code> section with parameters <code>executionMinPeriod</code> and <code>executionBurst</code>. These parameters are used to throttle hook executions and wait for more events in the queue. See section <a href="https://flant.github.io/shell-operator/HOOKS.html#execution-rate">execution rate</a> from the Shell-operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="values-storage"><a class="header" href="#values-storage">Values storage</a></h1>
<p>The Addon-operator provides the storage for the values that will be passed to the Helm chart. You may find out more about the chart values concept in the Helm documentation: <a href="https://helm.sh/docs/chart_template_guide/#values-files">values files</a>. Global and module hooks have access to the values in the storage and can change them.</p>
<p>The storage is a hash-like data structure. The <code>global</code> key contains all global values – they are passed to every hook and available to all Helm charts. Only global hooks may change global values.</p>
<p>The other keys must match the <a href="MODULES.html#module-structure">module’s name</a> converted to camelCase. Each key stores the object with module values. These values are only available to hooks, <code>enabled</code> script of this module, and to its Helm chart. Only module hooks can change the values of the module.</p>
<blockquote>
<p><strong>Note:</strong> You cannot get the values of another module within the module hook. Shared values should be global values for now (#9).</p>
</blockquote>
<p>Hook receives values via files on execution. These schemas can help you understand the flow of values for a global hook and for a module hook:</p>
<p align="center">
<img width="1024" src="image/module_values_flow.png" alt="Flow of values for module hook" />
</p>
<p align="center">
<img width="1024" src="image/global_values_flow.png" alt="Flow of values for global hook" />
</p>
<p>The values can be represented as:</p>
<ul>
<li>a structure (including empty structure)</li>
<li>a list (including empty list)</li>
</ul>
<p>Structures and lists must be JSON-compatible since hooks receive values at runtime as JSON files (see <a href="VALUES.html#using-values-in-the-hook">using values in hook</a>).</p>
<blockquote>
<p><strong>Note:</strong> each module has an additional key with <code>Enabled</code> suffix and a boolean value to enable or disable the module (e.g., <code>ingressNginxEnabled: false</code>). This key is handled by <a href="LIFECYCLE.html#modules-discovery">modules discovery</a> process.</p>
</blockquote>
<h2 id="valuesyaml-1"><a class="header" href="#valuesyaml-1"><code>values.yaml</code></a></h2>
<p>On start-up, the Addon-operator loads values into storage from <code>values.yaml</code> files:</p>
<ul>
<li><code>$MODULES_DIR/values.yaml</code></li>
<li><code>values.yaml</code> files in modules directories — only the values from key with camelCase name of the module</li>
</ul>
<p>An example of global values in <code>$MODULES_DIR/values.yaml</code>:</p>
<pre><code class="language-yaml">global:
  param1: value1
  param2: value2
simpleModule:
  modParam1: value3
</code></pre>
<p>An example of module values in <code>$MODULES_DIR/001-simple-module/values.yaml</code>:</p>
<pre><code class="language-yaml">simpleModule:
  modParam1: value1
  modParam2: value2
</code></pre>
<h2 id="configmapaddon-operator"><a class="header" href="#configmapaddon-operator">ConfigMap/addon-operator</a></h2>
<p>There is a key <code>global</code> in the ConfigMap/addon-operator that contains global values and the keys with module values. The values are stored in these keys as the YAML encoded strings. Values in the ConfigMap/addon-operator override the values loaded from <code>values.yaml</code> files.</p>
<p>The Addon-operator monitors changes in the ConfigMap/addon-operator and starts the ‘reload all modules’ process in case of global values changes or ‘module run’ process if only the module section is changed. See <a href="LIFECYCLE.html">LIFECYCLE</a>.</p>
<p>An example of ConfigMap/addon-operator:</p>
<pre><code class="language-yaml">data:
  global: | # vertical bar is required here
    param1: newValue
    param3: valu3
  simpleModule: | # module name should be in camelCase
    modParam2: newValue2
  anotherModule: &quot;false&quot; # `false' value disables a module
</code></pre>
<h2 id="update-values"><a class="header" href="#update-values">Update values</a></h2>
<p>Hooks can update values in the storage. To do that the hook returns a <a href="http://jsonpatch.com/">JSON Patch</a>.</p>
<p>A hook can update values in the ConfigMap/addon-operator so that the updated values would be available after restarting the Addon-operator (long-term update). For example, you may store generated passwords or certificates.</p>
<p>Patch for a long-term update is returned via the <code>$CONFIG_VALUES_JSON_PATCH_PATH</code> file and after hook execution, the Addon-operator immediately applies this patch to the values in ConfigMap/addon-operator.</p>
<p>Another option is to store updated values for a period while the Addon-operator process is running. For example, you may store the results of the discovery of cluster resources or parameters.</p>
<p>Patch for temporary updates is returned via the <code>$VALUES_JSON_PATCH_PATH</code> file and remains in the Addon-operator volatile memory.</p>
<h2 id="merged-values"><a class="header" href="#merged-values">Merged values</a></h2>
<p>When the hook or <code>enabled</code> script is about to be executed, or a Helm chart is to be installed, the Addon-operator generates <em>a merged set of values</em>. This merged set combines:</p>
<ul>
<li>global values from <code>values.yaml</code> files and ConfigMap/addon-operator;</li>
<li>module values from the <code>values.yaml</code> files and ConfigMap/addon-operator;</li>
<li>patches for the temporary updates are applied.</li>
</ul>
<p>The merged values are passed as the temporary JSON file to hooks or <code>enabled</code> script and as the temporary <code>values.yaml</code> file to the <code>helm install</code>.</p>
<h2 id="using-values-in-the-hook"><a class="header" href="#using-values-in-the-hook">Using values in the hook</a></h2>
<p>When the hook is triggered by an event, the values are passed to it via JSON files. The hook can use environment variables to get paths of those files:</p>
<ul>
<li><code>$CONFIG_VALUES_PATH</code> — this file contains values from the ConfigMap/addon-operator.</li>
<li><code>$VALUES_PATH</code> — this file contains merged values.</li>
</ul>
<p>For global hooks, only global values are available.</p>
<p>For module hooks the global values and the module values are available. Also, the <code>enabledModules</code> field is added to the <code>global</code> values in the <code>$VALUES_PATH</code> file. It contains the list of all enabled modules in the order of execution (see <a href="LIFECYCLE.html#module-lifecycle">module lifecycle</a>).</p>
<p>To change the values, the hook must return JSON patches via the result files. The hook can use environment variables to get paths of those files:</p>
<ul>
<li><code>$CONFIG_VALUES_JSON_PATCH_PATH</code> — hook should write a patch for ConfigMap/addon-operator into this file.</li>
<li><code>$VALUES_JSON_PATCH_PATH</code> — hook should write a patch for a temporary update of parameters into this file.</li>
</ul>
<h2 id="using-the-values-in-enabled-scripts"><a class="header" href="#using-the-values-in-enabled-scripts">Using the values in <code>enabled</code> scripts</a></h2>
<p>The <code>enabled</code> script works with values in the read-only mode. It receives values in JSON files. The script can use environment variables to get paths of those files:</p>
<ul>
<li><code>$CONFIG_VALUES_PATH</code> — this file contains values from ConfigMap/addon-operator.</li>
<li><code>$VALUES_PATH</code> — this file contains merged values.</li>
</ul>
<p>The <code>enabledModules</code> field with the list of previously enabled modules is added to the <code>global</code> key in the <code>$VALUES_PATH</code> file.</p>
<h2 id="using-values-in-helm-charts"><a class="header" href="#using-values-in-helm-charts">Using values in Helm charts</a></h2>
<p>Helm chart of the module has access to the merged values similar to the <code>$VALUES_PATH</code> but without <code>enabledModules</code> field.</p>
<p>The Helm template’s variable <code>.Values</code> allows you to use values in the templates:</p>
<pre><code class="language-text">{{ .Values.global.param1 }}

{{ .Values.moduleName.modParam2 }}
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let’s assume the following values are defined:</p>
<pre><code class="language-shell">$ cat modules/values.yaml:

global:
  param1: 100
  param2: &quot;Yes&quot;

$ cat modules/01-some-module/values.yaml

someModule:
  param1: &quot;String&quot;

$ kubectl -n addon-operator get cm/addon-operator -o yaml

data:
  global: |
    param1: 200
  someModule: |
    param1: &quot;Long string&quot;
    param2: &quot;FOO&quot;
</code></pre>
<p>The Addon-operator generates the following files with values:</p>
<pre><code class="language-shell">$ cat $CONFIG_VALUES_PATH

{&quot;global&quot;:{
    &quot;param1&quot;:200
}, &quot;someModule&quot;:{
    &quot;param1&quot;:&quot;Long string&quot;,
    &quot;param2&quot;: &quot;FOO&quot;
}}

$ cat $VALUES_PATH

{&quot;global&quot;:{
    &quot;param1&quot;:200,
    &quot;param2&quot;: &quot;YES&quot;
}, &quot;someModule&quot;:{
    &quot;param1&quot;:&quot;Long string&quot;,
    &quot;param2&quot;: &quot;FOO&quot;
}}

</code></pre>
<p>A hook adds a new value with the help of a JSON patch:</p>
<pre><code class="language-shell">$ cat /modules/001-some-module/hooks/hook.sh

#!/usr/bin/env bash
...
cat &gt; $CONFIG_VALUES_JSON_PATCH_PATH &lt;&lt;EOF
    [{&quot;op&quot;:&quot;add&quot;, &quot;path&quot;:&quot;/someModule/param3&quot;, &quot;value&quot;:&quot;newValue&quot;}]
EOF
...
</code></pre>
<p>Now the ConfigMap/addon-operator has the following content:</p>
<pre><code class="language-shell">data:
  global: |
    param1: 200
  someModule: |
    param1: &quot;Long string&quot;
    param2: &quot;FOO&quot;
    param3: &quot;newValue&quot;
</code></pre>
<p>Next time the hook is executed, the Addon-operator would generate the following files with values:</p>
<pre><code class="language-shell">$ cat $CONFIG_VALUES_PATH

{&quot;global&quot;:{
    &quot;param1&quot;:200
},
&quot;someModule&quot;:{
    &quot;param1&quot;:&quot;Long string&quot;,
    &quot;param2&quot;: &quot;FOO&quot;,
    &quot;param3&quot;: &quot;newValue&quot;
}}

$ cat $VALUES_PATH

{&quot;global&quot;:{
    &quot;param1&quot;:200,
    &quot;param2&quot;: &quot;YES&quot;
}, &quot;someModule&quot;:{
    &quot;param1&quot;:&quot;Long string&quot;,
    &quot;param2&quot;: &quot;FOO&quot;,
    &quot;param3&quot;: &quot;newValue&quot;
}}
</code></pre>
<p>Helm chart template
<code>replicas: {{ .Values.global.param1 }}</code>
would generate the string <code>replicas: 200</code>. As you can see, the value “100” from the values.yaml is replaced by “200” from the ConfigMap/addon-operator.</p>
<h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>The addon-operator supports OpenAPI schemas for config values and for effective values. These schemas should be stored in the <code>$GLOBAL_HOOKS_DIR/openapi</code> directory for global values and in the <code>$MODULES_DIR/&lt;module-name&gt;/openapi</code> directories for modules.</p>
<p><code>openapi/config-values.yaml</code> is a schema for values merged from values.yaml, modules/values.yaml and the ConfigMap.</p>
<p><code>openapi/values.yaml</code> is a schema for values merged from values.yaml, modules/values.yaml and the ConfigMap with applied values patches.</p>
<p>Validation occurs on startup, on ConfigMap changes, and after hook executions. If validation fails after hook execution, hook is restarted. If validation fails on startup, the addon-operator stops. If validation fails on ConfigMap changes, error is logged and no new tasks are queued.</p>
<blockquote>
<p>Note: Unlike the default behavior, the addon-operator sets <code>additionalProperties: false</code> if <code>additionalProperties</code> is not set.</p>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-yaml"># /global/openapi/config-values.yaml

type: object
additionalProperties: false
required:
  - project
  - clusterName
minProperties: 2
properties:
  project:
    type: string
  clusterName:
    type: string
  clusterHostname:
    type: string
  discovery:
    type: object
</code></pre>
<p>This schema defines 2 required fields for ‘global’ values: <code>project</code> and <code>clusterName</code>. <code>clusterHostname</code> field is an optional string. <code>discovery</code> is an optional object with no restrictions on keys.</p>
<p>Consider this <code>ConfigMap/addon-operator</code> content:</p>
<pre><code class="language-yaml">metadata:
...
data:
  global: |
    project: myProject
  moduleOne: |
    param1: value1
...
</code></pre>
<p>This ConfigMap has invalid ‘global’ values, and the addon-operator stops with an error on startup.</p>
<p>Consider valid <code>ConfigMap/addon-operator</code> and this config patch from global hook:</p>
<pre><code class="language-json">[{&quot;op&quot;:&quot;add&quot;, &quot;path&quot;:&quot;/global/clusterHostname&quot;, &quot;value&quot;:&quot;{}&quot;}]
</code></pre>
<p>This patch sets <code>clusterHostname</code> field in the ‘global’ section. It is not allowed because schema defines <code>clusterHostname</code> as a string. This situation is handled like a hook execution error, the hook stays in queue and restarts with exponential backoff (see <a href="LIFECYCLE.html#task-queues">LIFECYCLE</a>.</p>
<h2 id="extending"><a class="header" href="#extending">Extending</a></h2>
<p>Values are config values with applied patches, so schema in values.yaml should contain duplicates of properties from config-values.yaml schema. There is a technique with <code>allOf</code> to reduce <a href="https://github.com/json-schema-org/json-schema-spec/issues/348">duplicates</a>, but it will not eliminate duplicates when <code>additionalProperties: false</code>. To overcome this problem, we implement custom property <code>x-extend</code> for values.yaml schema.</p>
<p>If values.yaml schema contains <code>x-extend</code> field, shell-operator extends fields in values.yaml schema with fields from config-values.yaml schema:</p>
<ul>
<li>definitions</li>
<li>required</li>
<li>properties</li>
<li>patternProperties</li>
<li>title</li>
<li>description</li>
</ul>
<p>Also, “x-*“ properties copied from config-values.yaml schema.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>Consider these OpenAPI schemas:</p>
<pre><code class="language-yaml"># /global/openapi/config-values.yaml

type: object
additionalProperties: false
required:
  - project
  - clusterName
properties:
  project:
    type: string
  clusterName:
    type: string
  clusterHostname:
    type: string
</code></pre>
<pre><code class="language-yaml"># /global/openapi/values.yaml

x-extend:
  schema: config-values.yaml
type: object
additionalProperties: false
required:
  - discovery
  - param1
properties:
  discovery:
    type: object
  param1:
    type: string
</code></pre>
<p>The addon-operator will validate values with this effective schema:</p>
<pre><code class="language-yaml"># effective schema for values

type: object
additionalProperties: false
required:
  - project
  - clusterName
  - discovery
  - param1
properties:
  project:
    type: string
  clusterName:
    type: string
  clusterHostname:
    type: string
  discovery:
    type: object
  param1:
    type: string
</code></pre>
<h2 id="defaults"><a class="header" href="#defaults">Defaults</a></h2>
<p>The addon-operator respects <code>default</code> key in schemas and apply defaults when merge values.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>Consider this schema for global values:</p>
<pre><code class="language-yaml"># /global/openapi/values.yaml

x-extend:
  schema: config-values.yaml
type: object
additionalProperties: false
required:
  - param1
properties:
  discovery:
    type: object
    default:
      {}
  param1:
    type: string
</code></pre>
<p>The addon-operator will add <code>discovery</code> with empty object to values if no <code>discovery</code> key is present in the ConfigMap, <code>modules/values.yaml</code> or in patches.</p>
<h2 id="required-fields"><a class="header" href="#required-fields">Required fields</a></h2>
<p>There is a problem with <code>required</code> fields defined in <code>openapi/values.yaml</code>: values for Helm can be constructed by multiple hooks. Different hooks return different portions of <code>required</code> fields and validation will fail on hook execution. To define a contract for Helm values in this situation, the addon-operator implements <code>x-required-for-helm</code> to define required values for Helm. Values are checked before helm execution with <code>x-required-for-helm</code> array merged with <code>required</code>.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<p>Suppose we have two hooks: one hook prepares a <code>param1</code> value and the second hook prepares a <code>param2</code> value. Helm required both fields, but we can’t require both fields after each hook execution. <code>x-required-for-helm</code> to the rescue:</p>
<pre><code class="language-yaml"># /global/openapi/values.yaml

type: object
x-required-for-helm:
  - param1
  - param2
properties:
  param1:
    type: string
  param2:
    type: string
</code></pre>
<p>The addon-operator will validate values <em>after each hook execution</em> with this effective schema:</p>
<pre><code class="language-yaml"># effective schema for values

type: object
additionalProperties: false
properties:
  param1:
    type: string
  param2:
    type: string
</code></pre>
<p>The addon-operator will validate values <em>before Helm execution</em> with this effective schema:</p>
<pre><code class="language-yaml"># effective schema for values

type: object
additionalProperties: false
required:
  - param1
  - param2
properties:
  param1:
    type: string
  param2:
    type: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addon-operator-metrics"><a class="header" href="#addon-operator-metrics">Addon-operator metrics</a></h1>
<p>The Addon-operator implements Prometheus target at <code>/metrics</code> endpoint. The default port is <code>9650</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<ul>
<li>
<p><code>addon_operator_binding_count{module=&quot;&quot;, hook=&quot;&quot;}</code> — a gauge with bindings count for every hooks. Global hooks has empty “module” label.</p>
</li>
<li>
<p><code>addon_operator_config_values_errors_total{}</code> — a counter of ConfigMap validation errors after <code>kubectl edit</code>. See <a href="metrics/../VALUES.html#validation">validation</a>.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_seconds{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a histogram with hook execution times. “hook” label is a name of the hook, “binding” is a binding name from configuration, “queue” is a queue name where hook is queued and “activation” is an event that triggers hook execution.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_errors_total{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> – this is the counter of hooks’ execution errors. It only tracks errors of hooks with the disabled <code>allowFailure</code> (i.e. respective key is omitted in the configuration or the <code>allowFailure: false</code> parameter is set). This metric has a “hook” label with the name of a failed hook.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_allowed_errors_total{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> – this is the counter of hooks’ execution errors. It only tracks errors of hooks that are allowed to exit with an error (the parameter <code>allowFailure: true</code> is set in the configuration). The metric has a “hook” label with the name of a failed hook.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_success_total{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> – this is the counter of hooks’ success execution. The metric has a “hook” label with the name of a succeeded hook.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_sys_cpu_seconds{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a histogram with global hook system cpu seconds.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_user_cpu_seconds{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a histogram with global hook user cpu seconds.</p>
</li>
<li>
<p><code>addon_operator_global_hook_run_max_rss_bytes{hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a gauge with global hook max rss usage in bytes.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_seconds{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a histogram with module hook execution times. “module” label is a name of the module, “hook” label is a name of the hook, “binding” is a binding name from configuration, “queue” is a queue name where hook is queued and “activation” is an event that triggers hook execution.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_errors_total{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> – this is the counter of hooks’ execution errors. It only tracks errors of hooks with the disabled <code>allowFailure</code> (i.e. respective key is omitted in the configuration or the <code>allowFailure: false</code> parameter is set). This metric has a “hook” label with the name of a failed hook.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_allowed_errors_total{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> – this is the counter of hooks’ execution errors. It only tracks errors of hooks that are allowed to exit with an error (the parameter <code>allowFailure: true</code> is set in the configuration). The metric has a “hook” label with the name of a failed hook.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_success_total{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> – this is the counter of hooks’ success execution. The metric has a “hook” label with the name of a succeeded hook.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_sys_cpu_seconds{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a histogram with module hook system cpu seconds.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_user_cpu_seconds{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a histogram with module hook user cpu seconds.</p>
</li>
<li>
<p><code>addon_operator_module_hook_run_max_rss_bytes{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, activation=&quot;&quot;, queue=&quot;&quot;}</code> — a gauge with module hook max rss usage in bytes.</p>
</li>
<li>
<p><code>addon_operator_module_discover_errors_total</code> – a counter of errors during the <a href="metrics/../LIFECYCLE.html#modules-discover">modules discover</a> process. It increases in these cases:</p>
<ul>
<li>an ‘enabled’ script is executed with an error</li>
<li>a module hook return an invalid configuration</li>
<li>a call to the Kubernetes API ends with an error (for example, retrieving Helm releases).</li>
</ul>
</li>
<li>
<p><code>addon_operator_module_run_errors_total{module=x}</code> – counter of errors on module <a href="metrics/../LIFECYCLE.html#modules-lifecycle">start-up</a>.</p>
</li>
<li>
<p><code>addon_operator_module_delete_errors_total{module=x}</code> – counter of errors on module <a href="metrics/../LIFECYCLE.html#modules-lifecycle">deletion</a>.</p>
</li>
<li>
<p><code>addon_operator_module_run_seconds{module=&quot;&quot;}</code> — a histogram with module execution timings.</p>
</li>
<li>
<p><code>addon_operator_module_helm_seconds{module=&quot;&quot;, activation=&quot;&quot;}</code> — a histogram of module’s <code>helm upgrade</code> timings.</p>
</li>
<li>
<p><code>addon_operator_helm_operation_seconds{module=&quot;&quot;, activation=&quot;&quot;, operation=&quot;&quot;}</code> — a histogram of different helm operations timings.</p>
</li>
<li>
<p><code>addon_operator_convergence_seconds{activation=onStartup}</code> — a counter of seconds spent to execute “reload all modules” processes. “activation=OnStartup” label value can be used to retrieve information about first “reload all modules” when operator starts.</p>
</li>
<li>
<p><code>addon_operator_convergence_total{activation=onStartup}</code> — a counter of “reload all modules” processes.</p>
</li>
<li>
<p><code>addon_operator_tasks_queue_length{queue=&quot;&quot;}</code> – a gauge showing the length of the working queue. This metric can be used to warn about stuck hooks. It has the “queue” label with the queue name.</p>
</li>
<li>
<p><code>addon_operator_task_wait_in_queue_seconds_total{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, queue=&quot;&quot;}</code> — a counter with seconds that the task is elapsed in the queue.</p>
</li>
<li>
<p><code>addon_operator_live_ticks</code> – a counter that increases every 10 seconds. This metric can be used for alerting about an unhealthy Addon-operator. It has no labels.</p>
</li>
<li>
<p><code>addon_operator_kube_jq_filter_duration_seconds{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, queue=&quot;&quot;, kind=&quot;&quot;}</code> — a histogram with jq filter timings.</p>
</li>
<li>
<p><code>addon_operator_kube_event_duration_seconds{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, queue=&quot;&quot;, kind=&quot;&quot;}</code> — a histogram with kube event handling timings.</p>
</li>
<li>
<p><code>addon_operator_kube_snapshot_objects{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, queue=&quot;&quot;}</code> — a gauge with count of cached objects (the snapshot) for particular binding. “module” label is empty for global hook.</p>
</li>
<li>
<p><code>addon_operator_kube_snapshot_bytes{module=&quot;&quot;, hook=&quot;&quot;, binding=&quot;&quot;, queue=&quot;&quot;}</code> — a gauge with size in bytes of cached objects for particular binding. Each cached object contains a Kubernetes object and/or result of jqFilter depending on the binding configuration. The size is a sum of the length of Kubernetes object in JSON format and the length of jqFilter‘s result in JSON format.</p>
</li>
<li>
<p><code>addon_operator_kubernetes_client_request_result_total</code> — a counter of requests made by kubernetes/client-go library.</p>
</li>
<li>
<p><code>addon_operator_kubernetes_client_request_latency_seconds</code> — a histogram with latency of requests made by kubernetes/client-go library.</p>
</li>
<li>
<p><code>addon_operator_tasks_queue_action_duration_seconds{queue_name=&quot;&quot;, queue_action=&quot;&quot;}</code> — a histogram with measurements of low level queue operations. Use QUEUE_ACTIONS_METRICS=”no” to disable this metric.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-metrics"><a class="header" href="#custom-metrics">Custom metrics</a></h1>
<p>Hooks can export metrics by writing a set of operations in JSON format into $METRICS_PATH file.</p>
<p>Operation to register a counter and increase its value:</p>
<pre><code class="language-json">{&quot;name&quot;:&quot;metric_name&quot;,&quot;action&quot;:&quot;add&quot;,&quot;value&quot;:1,&quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}
</code></pre>
<p>Operation to register a gauge and set its value:</p>
<pre><code class="language-json">{&quot;name&quot;:&quot;metric_name&quot;,&quot;action&quot;:&quot;set&quot;,&quot;value&quot;:33,&quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}
</code></pre>
<p>Operation to register a histogram and observe a duration:</p>
<pre><code class="language-json">{&quot;name&quot;:&quot;metric_name&quot;,&quot;action&quot;:&quot;observe&quot;,&quot;value&quot;:42, &quot;buckets&quot;: [1,2,5,10,20,50], &quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}
</code></pre>
<p>Labels are not required, but Shell-operator adds a <code>hook</code> label with a path to a hook script relative to hooks directory.</p>
<p>Several metrics can be exported at once. For example, this script will create 2 metrics:</p>
<pre><code>echo '{&quot;name&quot;:&quot;hook_metric_count&quot;,&quot;action&quot;:&quot;add&quot;,&quot;value&quot;:1,&quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;name&quot;:&quot;hook_metrics_items&quot;,&quot;action&quot;:&quot;add&quot;,&quot;value&quot;:1,&quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}' &gt;&gt; $METRICS_PATH
</code></pre>
<p>The metric name is used as-is, so several hooks can export the same metric name. It is responsibility of hooks‘ developer to maintain consistent label cardinality.</p>
<p>There are fields “add” and “set” that can be used as shortcuts for action and value. This feature may be deprecated in future releases.</p>
<pre><code>{&quot;name&quot;:&quot;metric_name&quot;,&quot;add&quot;:1,&quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}
</code></pre>
<p>Note that there is no mechanism to expire this kind of metrics except the addon-operator restart. It is the default behavior of prometheus-client.</p>
<h3 id="grouped-metrics"><a class="header" href="#grouped-metrics">Grouped metrics</a></h3>
<p>The common cause to expire a metric is a removed object. It means that the object is no longer in the snapshot, and the hook can’t identify the metric that should be expired.</p>
<p>To solve this, use the “group” field in metric operations. When Shell-operator receives operations with the “group” field, it expires previous metrics with the same group and applies new metric values. This grouping works across hooks and label values.</p>
<pre><code>echo '{&quot;group&quot;:&quot;group1&quot;, &quot;name&quot;:&quot;hook_metric_count&quot;,  &quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;group1&quot;, &quot;name&quot;:&quot;hook_metrics_items&quot;, &quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}' &gt;&gt; $METRICS_PATH
</code></pre>
<p>To expire all metrics in a group, use action “expire”:</p>
<pre><code>{&quot;group&quot;:&quot;group_name_1&quot;, &quot;action&quot;:&quot;expire&quot;}
</code></pre>
<p><strong>WARNING</strong>: “observe” is currently an unsupported <em>action</em> for grouped metrics</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<p><code>hook1.sh</code> returns these metrics:</p>
<pre><code>echo '{&quot;group&quot;:&quot;hook1&quot;, &quot;name&quot;:&quot;hook_metric&quot;, &quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;kind&quot;:&quot;pod&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;hook1&quot;, &quot;name&quot;:&quot;hook_metric&quot;, &quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;kind&quot;:&quot;replicaset&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;hook1&quot;, &quot;name&quot;:&quot;hook_metric&quot;, &quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;kind&quot;:&quot;deployment&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;hook1&quot;, &quot;name&quot;:&quot;hook1_special_metric&quot;, &quot;action&quot;:&quot;set&quot;, &quot;value&quot;:12, &quot;labels&quot;:{&quot;label1&quot;:&quot;value1&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;hook1&quot;, &quot;name&quot;:&quot;common_metric&quot;, &quot;action&quot;:&quot;set&quot;, &quot;value&quot;:300, &quot;labels&quot;:{&quot;source&quot;:&quot;source3&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;name&quot;:&quot;common_metric&quot;, &quot;action&quot;:&quot;set&quot;, &quot;value&quot;:100, &quot;labels&quot;:{&quot;source&quot;:&quot;source1&quot;}}' &gt;&gt; $METRICS_PATH
</code></pre>
<p><code>hook2.sh</code> returns these metrics:</p>
<pre><code>echo '{&quot;group&quot;:&quot;hook2&quot;, &quot;name&quot;:&quot;hook_metric&quot;,&quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;kind&quot;:&quot;configmap&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;hook2&quot;, &quot;name&quot;:&quot;hook_metric&quot;,&quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;kind&quot;:&quot;secret&quot;}}' &gt;&gt; $METRICS_PATH
echo '{&quot;group&quot;:&quot;hook2&quot;, &quot;name&quot;:&quot;hook2_special_metric&quot;, &quot;action&quot;:&quot;set&quot;, &quot;value&quot;:42}' &gt;&gt; $METRICS_PATH
echo '{&quot;name&quot;:&quot;common_metric&quot;, &quot;action&quot;:&quot;set&quot;, &quot;value&quot;:200, &quot;labels&quot;:{&quot;source&quot;:&quot;source2&quot;}}' &gt;&gt; $METRICS_PATH
</code></pre>
<p>Prometheus scrapes these metrics:</p>
<pre><code># HELP hook_metric hook_metric
# TYPE hook_metric counter
hook_metric{hook=&quot;hook1.sh&quot;, kind=&quot;pod&quot;} 1 -------------------+---------- group:hook1
hook_metric{hook=&quot;hook1.sh&quot;, kind=&quot;replicaset&quot;} 1 ------------+
hook_metric{hook=&quot;hook1.sh&quot;, kind=&quot;deployment&quot;} 1 ------------+
hook_metric{hook=&quot;hook2.sh&quot;, kind=&quot;configmap&quot;} 1  ------------|-------+-- group:hook2
hook_metric{hook=&quot;hook2.sh&quot;, kind=&quot;secret&quot;} 1 ----------------|-------+
# HELP hook1_special_metric hook1_special_metric              |       |
# TYPE hook1_special_metric gauge                             |       |
hook1_special_metric{hook=&quot;hook1.sh&quot;, label1=&quot;value1&quot;} 12 ----+       |
# HELP hook2_special_metric hook2_special_metric              |       |
# TYPE hook2_special_metric gauge                             |       |
hook2_special_metric{hook=&quot;hook2.sh&quot;} 42 ---------------------|-------'
# HELP common_metric common_metric                            |
# TYPE common_metric gauge                                    |
common_metric{hook=&quot;hook1.sh&quot;, source=&quot;source3&quot;} 300 ---------'
common_metric{hook=&quot;hook1.sh&quot;, source=&quot;source1&quot;} 100 ---------------+---- no group
common_metric{hook=&quot;hook2.sh&quot;, source=&quot;source2&quot;} 200 ---------------'
</code></pre>
<p>On next execution of <code>hook1.sh</code> values for <code>hook_metric{kind=&quot;replicaset&quot;}</code>, <code>hook_metric{kind=&quot;deployment&quot;}</code>, <code>common_metric{source=&quot;source3&quot;}</code> and <code>hook1_special_metric</code> are expired and hook returns only one metric:</p>
<pre><code>echo '{&quot;group&quot;:&quot;hook1&quot;, &quot;name&quot;:&quot;hook_metric&quot;, &quot;action&quot;:&quot;add&quot;, &quot;value&quot;:1, &quot;labels&quot;:{&quot;kind&quot;:&quot;pod&quot;}}' &gt;&gt; $METRICS_PATH
</code></pre>
<p>Addon-operator expires previous values for group “hook1” and updates value for <code>hook_metric{hook=&quot;hook1.sh&quot;, kind=&quot;pod&quot;}</code>. Values for group <code>hook2</code> and <code>common_metric</code> without group are left intact. Now Prometheus scrapes these metrics:</p>
<pre><code># HELP hook_metric hook_metric
# TYPE hook_metric counter
hook_metric{hook=&quot;hook1.sh&quot;, kind=&quot;pod&quot;} 2 --------------- group:hook1
hook_metric{hook=&quot;hook2.sh&quot;, kind=&quot;configmap&quot;} 1 ----+---- group:hook2
hook_metric{hook=&quot;hook2.sh&quot;, kind=&quot;secret&quot;} 1 -------+
# HELP hook2_special_metric hook2_special_metric     |
# TYPE hook2_special_metric gauge                    |
hook2_special_metric{hook=&quot;hook2.sh&quot;} 42 ------------'
# HELP common_metric common_metric
# TYPE common_metric gauge
common_metric{hook=&quot;hook1.sh&quot;, source=&quot;source1&quot;} 100 --+-- no group
common_metric{hook=&quot;hook2.sh&quot;, source=&quot;source2&quot;} 200 --'
</code></pre>
<p>Next execution of <code>hook2.sh</code> expires all metrics in group ‘hook2’:</p>
<pre><code>echo '{&quot;group&quot;:&quot;hook2&quot;, &quot;action&quot;:&quot;expire&quot;}' &gt;&gt; $METRICS_PATH
</code></pre>
<p>Shell-operator expires previous values for group “hook2” but leaves <code>common_metrics</code> for “hook2.sh” as is. Now Prometheus scrapes these metrics:</p>
<pre><code># HELP hook_metric hook_metric
# TYPE hook_metric counter
hook_metric{hook=&quot;hook1.sh&quot;, kind=&quot;pod&quot;} 2 --------------- group:hook1
# HELP common_metric common_metric
# TYPE common_metric gauge
common_metric{hook=&quot;hook1.sh&quot;, source=&quot;source1&quot;} 100 --+-- no group
common_metric{hook=&quot;hook2.sh&quot;, source=&quot;source2&quot;} 200 --'
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
