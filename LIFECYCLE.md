# Structure

The module files are located in the `/modules` directory. The directory can be set via $MODULES_DIR variable. The global hook files are located in the `/global-hooks` directory (you can set your own directory with the $GLOBAL_HOOKS_DIR variable).

# Initialization

During the start, Addon-operator finds and initializes all global hooks. For more info, see [HOOKS](HOOKS.md#initialization-of-global-hooks).

# Main loop

After initialization Addon-operator executes all global `onStartup` hooks and starts the modules discovery process.

The modules discovery process finds all enabled modules and starts them.

During start-up, the module executes its `onStartup` hook and initializes the installation of a helm chart. Prior to the installation of a helm chart, the `beforeHelm` hook is executed. The `afterHelm` hook is executed after the installation.

Then the main loop starts. It processes scheduled and Kubernetes objects’ events, as well as a module activation event when values change and the modules restart event.

# Module lifecycle

The `onStartup` hooks of all modules are executed during the first deployment of a Pod with an Addon-operator.

Next, the modules are run in alphabetical order with `helm upgrade --install`. Prior to launching helm, `beforeHelm` hooks are executed, after the launch the `afterHelm` hooks are executed.

After the launch module would start to respond to two types of events:

- `schedule` — events that are generated by the crontab scheduler built in the addon-operator;
- `onKubernetesEvent` — events within the cluster that api-server announces to Addon-operator.

When module is deactivated, Addon-operator launch command `helm delete --purge` and after the release deletion, the `afterDeleteHelm` hooks are executed.

All necessary hooks will be restarted if there are errors during the module activation or deactivation. For example, if an error occurred in the hook with `afterHelm` binding during the first module execution, then after a 5 seconds delay the `onStartup` and `beforeHelm` hooks are executed, the helm chart is installed and then `afterHelm` hooks are executed.

# Modules discovery

Addon-operator makes a list of all enabled modules for their execution and a list of disabled modules for the deletion of their helm releases. This process is called `module discovery` and is started in the following cases:

- during the start of addon-operator
- when an event to restart all modules occurs (see [VALUES](VALUES.md)).

Modules are disabled by default. The module can be enabled by a key with the module name suffixed by `Enabled`. This key should contain a boolean value and can be specified in these sources:

- $MODULES_DIR/values.yaml
- `values.yaml` files in modules directories
- ConfigMap/addon-operator

Boolean values from values.yaml files and ConfigMap/addon-operator are combined and if the result is equal to `false` or is empty, then the module is disabled.

If the value is `true`, the additional check is performed – the `enabled` script is executed (see below). If the script is present in the module and it returns `false`, then the module is considered disabled. If the script is not present or returns `true`, then the module is enabled.

If an error occurs during the modules discovery process, then the module discovery is restarted every 5 seconds until successful execution. In this case, the execution of hooks with `schedule` and `onKubernetesEvent` bindings will be blocked.

As a result of a module discovery process the tasks for the execution of all *enabled* modules, deletion of all *disabled* modules, and execution of all global hook with the `afterAll` binding are added to the queue.

## Enabled script

A script or an executable file that returns a status of the module. The script has access to the module values in $VALUES_PATH and $CONFIG_VALUES_PATH files, more details about the values are available in [VALUES](VALUES.md#using-values-in-enabled-script). The variable $MODULE_ENABLED_RESULT passes the path to the file into which the script should write the module status: true or false.

Below is an example of the `enabled` script that disables the module when parameter `param2` is set to "stopMePlease".


```bash
#!/usr/bin/env bash

param2=$(jq -r '.simpleModule.param2' $VALUES_PATH)

if [[ $param2 == "stopMePlease" ]] ; then
  echo "false" > $MODULE_ENABLED_RESULT
else
  echo "true" > $MODULE_ENABLED_RESULT
fi

```

## Examples

### keys in values.yaml files

Let’s assume the module named `nginx-ingress` and the following values are defined:

```
$ cat modules/values.yaml

nginxIngressEnabled: true

$ cat modules/001-nginx-ingress/values.yaml

nginxIngressEnabled: false
```

Module `nginx-ingress` is disabled in `modules/values.yaml` but enabled in `modules/001-nginx-ingress/values.yaml`. The final result is that the module is disabled.

Also note that module's directory name is kebab-cased but keys in values.yaml are camelCased (see [VALUES](VALUES.md#values-storage)).

### values.yaml and ConfigMap 

Let’s assume the following values and enabled script are defined:

```
$ cat modules/values.yaml

global:
  param1: 100
someModuleEnabled: false

$ cat modules/001-some-module/values.yaml

someModule:
  param1: "String"


$ kubectl -n addon-operator get cm/addon-operator -o yaml

data:
  global: |
    param1: 200
  someModule: |
    param1: "Long string"
    param2: "FOO"
  someModuleEnabled: "true"

$ cat modules/01-some-module/enabled

#!/bin/bash

echo false > $MODULE_ENABLED_RESULT
```

Module `some-module` is explicitly disabled in `modules/values.yaml` but enabled by `someModuleEnabled` key in ConfigMap/addon-operator. Thus enabled script is executed and returns `false`. So the final result is that the module is disabled.

# Tasks queue

Addon-operator cycle works like a simple FIFO queue. The Addon-operator processes an event, creates a task and adds it to the queue. The queue handler runs the current task and proceeds to the next. Each task is processed until successful completion. In case of an error, the task is returned to the top of the queue and executed after a 5 seconds delay. When executing tasks for the `onKubernetesEvent` and `schedule` events, the queue handler may ignore the execution errors if the `allowFailure: true` flag is specified in the binding configuration.

# Queue monitoring

You can use Prometheus metrics to monitor the queue. For details, see [METRICS](METRICS.md).

# Debug

Several tools are available for the debugging of addon-operator and hooks:

- You can get logs of an Addon-operator’s pod for analysis (by executing `kubectl logs -f po/POD_NAME`)
- You can set the environment variable RLOG_LOG_LEVEL=DEBUG to include the detailed debugging data into logs
- You can view the contents of the working queue via the HTTP request of `/queue` endpoint:

```bash
kubectl port-forward po/addon-operator 9115:9115

curl localhost:9115/queue
```
